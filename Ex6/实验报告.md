# 实验6 zkSNARK 实验报告

## 一、实验目的

1. 学习使用 circom 描述算术电路
2. 学习使用 snarkjs 生成和验证 zk-SNARKs 证明
3. 理解 Tornado Cash 私有交易的实现原理
4. 掌握 Merkle 树在零知识证明中的应用

---

## 二、实验环境

- 操作系统: Ubuntu (WSL)
- Node.js: v22.21.1
- npm: 10.9.4
- 依赖库: snarkjs@0.1.11, circom, mocha

---

## 三、核心代码实现

### 3.1 IfThenElse 电路

**功能**：根据条件选择输出 true_value 或 false_value

```circom
template IfThenElse() {
    signal input condition;
    signal input true_value;
    signal input false_value;
    signal output out;

    // 约束 condition 必须是 0 或 1
    condition * (1 - condition) === 0;

    // out = condition * true_value + (1 - condition) * false_value
    signal helper;
    helper <== condition * true_value;
    out <== helper + false_value - condition * false_value;
}
```

**说明**：
- 使用 `condition * (1 - condition) === 0` 约束条件必须为二进制值
- 利用辅助信号 `helper` 避免直接在输出中进行多个信号相乘

---

### 3.2 SelectiveSwitch 电路

**功能**：根据选择信号 s 决定是否交换两个输入的顺序

```circom
template SelectiveSwitch() {
    signal input in0;
    signal input in1;
    signal input s;
    signal output out0;
    signal output out1;

    component ite0 = IfThenElse();
    component ite1 = IfThenElse();

    ite0.condition <== s;
    ite0.true_value <== in1;
    ite0.false_value <== in0;
    out0 <== ite0.out;

    ite1.condition <== s;
    ite1.true_value <== in0;
    ite1.false_value <== in1;
    out1 <== ite1.out;
}
```

**说明**：
- 当 s=0 时保持原顺序：out0=in0, out1=in1
- 当 s=1 时交换顺序：out0=in1, out1=in0
- 复用 IfThenElse 组件实现

---

### 3.3 Spend 电路

**功能**：验证 H(nullifier, nonce) 是 Merkle 树中的一个叶子节点

```circom
template Spend(depth) {
    signal input digest;
    signal input nullifier;
    signal private input nonce;
    signal private input sibling[depth];
    signal private input direction[depth];

    // 计算币: H(nullifier, nonce)
    component coinHash = Mimc2();
    coinHash.in0 <== nullifier;
    coinHash.in1 <== nonce;

    // Merkle 路径验证
    signal pathHash[depth + 1];
    pathHash[0] <== coinHash.out;
    component switches[depth];
    component hashers[depth];

    for (var i = 0; i < depth; i++) {
        switches[i] = SelectiveSwitch();
        switches[i].in0 <== pathHash[i];
        switches[i].in1 <== sibling[i];
        switches[i].s <== direction[i];

        hashers[i] = Mimc2();
        hashers[i].in0 <== switches[i].out0;
        hashers[i].in1 <== switches[i].out1;
        pathHash[i + 1] <== hashers[i].out;
    }

    digest === pathHash[depth];
}
```

**说明**：
- 首先使用 Mimc2 哈希计算 coin = H(nullifier, nonce)
- 从叶子节点向上遍历 Merkle 路径
- 使用 SelectiveSwitch 根据 direction 决定当前节点和兄弟节点的左右顺序
- 最终验证计算出的根哈希等于提供的 digest

---

### 3.4 computeInput 函数

**功能**：为 Spend 电路计算输入参数

```javascript
function computeInput(depth, transcript, nullifier) {
    const tree = new SparseMerkleTree(depth);
    let targetNonce = null;
    let targetCoin = null;
    
    for (const entry of transcript) {
        let coin;
        if (entry.length === 1) {
            coin = entry[0];
        } else {
            const entryNullifier = entry[0];
            const entryNonce = entry[1];
            coin = mimc2(entryNullifier, entryNonce);
            if (entryNullifier === nullifier) {
                targetNonce = entryNonce;
                targetCoin = coin;
            }
        }
        tree.insert(coin);
    }
    
    const path = tree.path(targetCoin);
    const result = {
        "digest": tree.digest,
        "nullifier": nullifier,
        "nonce": targetNonce
    };
    
    for (let i = 0; i < depth; i++) {
        const [sibling, direction] = path[i];
        result[`sibling[${i}]`] = sibling;
        result[`direction[${i}]`] = direction ? "1" : "0";
    }
    return result;
}
```

**说明**：
- 构建 SparseMerkleTree 并插入所有 coins
- 找到目标 nullifier 对应的 nonce 和 coin
- 获取 Merkle 路径并格式化为电路输入格式

---

## 四、实验结果

### 4.1 测试结果

```
  IfThenElse
    ✓ should give `false_value` when `condition` = 0
    ✓ should give `true_value` when `condition` = 1
    ✓ should enforce that s in {0, 1}

  SelectiveSwitch
    ✓ should not switch when s = 0
    ✓ should switch when s = 1
    ✓ should enforce that s in {0, 1}

  computeInput
    ✓ transcript0.txt, depth 0, nullifier 1
    ✓ transcript1.txt, depth 4, nullifier 4
    ✓ transcript2.txt, depth 25, nullifier 7

  Spend
    ✓ witness computable for depth 0
    ✓ witness computable for depth 1
    ✓ witness computable for depth 2
    ✓ witness not computable for bad input

  13 passing (2s)
```

### 4.2 证明生成与验证

| 证明类型 | 参数 | 验证结果 |
|---------|------|---------|
| SmallOddFactorization | 7 × 17 × 19 = 2261 | OK ✓ |
| Spend | depth=10, nullifier=10137284576094 | OK ✓ |

---

## 五、Writeup 问答

### Question 1
**问**：为什么 `sum_of_bits += (2 ** i) * bits[i]` 是线性组合？

**答**：因为 `(2 ** i)` 是在编译时计算的常数，不是信号。常数乘以信号仍然是线性项。整个表达式是 `常数 × 信号` 的累加，符合线性组合的定义，不涉及两个信号相乘。

### Question 2
**问**：`<==` 操作符的含义是什么？

**答**：`<==` 同时执行两个操作：
1. 赋值 (`<--`)：将右侧值赋给左侧信号
2. 约束 (`===`)：添加等式约束

即 `a <== b` 等价于 `a <-- b; a === b;`

### Question 3
**问**：为什么 `(a & 1) * b === c` 是无效的？

**答**：位操作符 `&` 不能用于 circom 约束中。R1C 约束仅支持有限域上的加法和乘法运算。虽然 `&` 可以在赋值语句中用于计算 witness，但不能出现在约束语句中。

---

## 六、实验总结

本实验通过实现 Tornado Cash 风格的隐私交易电路，深入理解了：

1. **circom 电路编程**：信号、约束、组件的使用方法
2. **R1C 约束系统**：线性组合和秩1约束的概念
3. **Merkle 树证明**：如何在零知识证明中验证成员资格
4. **snarkjs 工作流程**：编译 → setup → witness → proof → verify

通过本实验，对零知识证明在区块链隐私保护中的应用有了更深的理解。
